package org.electrocodeogram.cpc.core.api.provider.xml;


import org.electrocodeogram.cpc.core.api.data.ICloneFile;
import org.electrocodeogram.cpc.core.api.data.ICloneObject;
import org.electrocodeogram.cpc.core.api.data.special.IStatefulObject;
import org.electrocodeogram.cpc.core.api.provider.IProvider;


/**
 * A mapping provider implements means of mapping {@link IStatefulObject} data to and from a string
 * representation. It provides "serialisation" functionality for CPC data objects.
 * <p>
 * The format of the string representation is not specified and is entirely up to the implementation.
 * <br>
 * However, each mapping provider should add some kind of special "magic" to the header which allows
 * itself to quickly decide whether a given string is likely to be in a mapping format which it supports.
 * <p>
 * <b>NOTE:</b> When mapping an external string representation to CPC objects it is recommended to use the
 * {@link IMappingRegistry} instead of directly accessing the default {@link IMappingProvider}. This
 * ensures that "legacy" mappings can still be read, even if the default mapping provider is changed.
 * 
 * @author vw
 * 
 * @see IMappingRegistry
 * @see MappingStore
 */
//TODO: rename the package to "mapping"
public interface IMappingProvider extends IProvider
{

	/**
	 * Does a quick check to see whether the given cpc data mapping is in a format which this
	 * mapping provider can understand.
	 * <br>
	 * Typically this method will only check some magic part of the data header and will not
	 * check the entire mapping document for integrity violations.
	 * <p>
	 * It is up to the implementation how to handle this method call.
	 * <br>
	 * However, this is a potentially very frequently called method and any implementation
	 * should try to optimise the performance of this method as far as possible. 
	 * 
	 * @param data the cpc data mapping to check, never null.
	 * @return <em>true</em> if this {@link IMappingProvider} is compatible with the given mapping format,
	 * 		<em>false</em> otherwise. A return value of <em>true</em> does not automatically indicate that the
	 * 		given mapping data is well formed and valid.
	 */
	public boolean isSupportedMappingFormat(String data);

	/**
	 * Takes a list of {@link IStatefulObject}s and maps them into a string representation.
	 * <br>
	 * The {@link MappingStore} and the contained {@link IStatefulObject}s may not be
	 * modified in any way by this method.
	 * 
	 * @param mappingStore a {@link MappingStore} which represents the {@link IStatefulObject}s which
	 * 		should be mapped to a string representation, never null.
	 * @param addHeaders whether a full set of headers should be added (<em>true</em>) or not (<em>false</em>).
	 * 		Some string representations may have special nesting semantics. This parameter can be used
	 * 		to indicate whether the result is intended to be nested within another string representation
	 * 		of the same type or whether it is meant to be used standalone.
	 * 		<br>
	 * 		I.e. for a XML mapping, this might turn the xml preamble on or off.
	 * @return string representation of the given stateful objects, never null.
	 * @throws MappingException if the data can not be mapped
	 */
	public String mapToString(MappingStore mappingStore, boolean addHeaders) throws MappingException;

	/**
	 * Takes a string representation which matches the ones generated by {@link IMappingProvider#mapToString(MappingStore, boolean)}
	 * and builds a {@link MappingStore} containing the {@link IStatefulObject} which the given mapping represents.
	 * 
	 * @param data a valid string representation which encodes {@link IStatefulObject} data, never null.
	 * @return a {@link MappingStore} with {@link IStatefulObject}s corresponding to the given mapping data, never null.
	 * @throws MappingException if the given string representation is not valid
	 */
	public MappingStore mapFromString(String data) throws MappingException;

	/**
	 * Takes a string representation which matches the ones generated by {@link IMappingProvider#mapToString(MappingStore, boolean)}
	 * and extracts the {@link ICloneObject#getUuid()} of the main object, if it exists and is of type {@link ICloneObject}.
	 * <br>
	 * The main object is the special object which was designated as parent object on creation of the string representation or
	 * the object, if there is exactly one object in the mapping.
	 * <br>
	 * Typically this is an {@link ICloneFile} file UUID.
	 * <p>
	 * Convenience method which is provided for performance reasons in situations where only the UUID of the main entry
	 * is of interest and where parsing of the entire file is therefore not needed.
	 * <br>
	 * It is up to the implementation to decide whether to implement this method separately or whether calls to this method
	 * should simply be mapped to {@link IMappingProvider#mapFromString(String)}.
	 * <br>
	 * This API makes no guarantee that using this method does provide any performance gain. Use of this method should be
	 * considered as an optimisation hint for the implementation.
	 * <p>
	 * An implementation is not required to do a full validity check of the given data structure. Thus there may be corrupted
	 * data structures for which a call to this method succeeds but a call to {@link IMappingProvider#mapFromString(String)} fails.
	 * 
	 * @param data a valid string representation which encodes {@link IStatefulObject} data, never null.
	 * @return the {@link ICloneObject#getUuid()} of the main object of this mapping structure or NULL if the given mapping structure
	 * 		contains multiple elements and no element was designated as parent element or if the main element is not of type
	 * 		{@link ICloneObject}.
	 * @throws MappingException if the given mapping structure is not valid
	 */
	public String extractCloneObjectUuidFromString(String data) throws MappingException;
}
